Ce projet sert a mettre en avant ce qu'un serveur comme apache fait a notre place. 
Ici je crÃ©e le serveur donc je dois tout faire.
 Par exemple avec l'utilisation d'apache on peut melanger le html et le php. 
Ici ce n'est pas possible mon serveur n'est pas assez puissant.
 La gestion des erreurs (400, 200...) des headers des routes... se fait manuellement ici
 La gestion des URLs


Mettre en route le serveur pr afficher ds le navigateur :
python serveur.py
Pour ne pas avoir a faire cette commande a chaque modification:
python dev_server.py

fichier dev_server.py :
Script Python qui surveille ton fichier et relance ton serveur Ã  chaque modification.

fichier serveur.py:

Etape 1 : CrÃ©ation du serveur

HTTPServer â†’ câ€™est le serveur HTTP qui Ã©coute les connexions.
SimpleHandler â†’ câ€™est ta classe qui hÃ©rite de BaseHTTPRequestHandler.
ğŸ‘‰ Quand un client (ton navigateur) envoie une requÃªte, HTTPServer crÃ©e une instance de SimpleHandler pour traiter cette requÃªte prÃ©cise.
Cette instance contient :
Les infos de la requÃªte (self.path, self.headers, self.rfile, etc.)
Les outils pour envoyer la rÃ©ponse (self.send_response, self.send_header, self.end_headers, self.wfile.write, â€¦).

Etape 2 : CrÃ©ation des routes 

Etape 3 : Formulaire de contact

le protocole HTTP impose que lorsquâ€™un serveur reÃ§oit une requÃªte (GET, POST, etc.), il doit toujours rÃ©pondre avec :

Un code de statut (200 OK, 404 Not Found, 500 Internal Server Error, â€¦).
ğŸ‘‰ Câ€™est self.send_response(200) qui envoie Ã§a.

Des en-tÃªtes HTTP (Content-Type, Content-Length, etc.).
ğŸ‘‰ Câ€™est self.send_header(...) suivi de self.end_headers() qui terminent la section en-tÃªtes.

Un corps de rÃ©ponse (optionnel, mais recommandÃ©).
ğŸ‘‰ Câ€™est self.wfile.write(...).
Quand tu fais un POST, le navigateur envoie les donnÃ©es (ton prÃ©nom, nom, message) dans le corps de la requÃªte.

âœ… Tu as crÃ©Ã© ton formulaire HTML (/contact).

âœ… Ton serveur reÃ§oit bien les requÃªtes POST (Ã§a nâ€™affiche plus dâ€™erreur).

âœ… On sait lire les donnÃ©es envoyÃ©es depuis le navigateur (avec self.rfile.read(...)).

âœ… parser les donnÃ©es pour les sÃ©parer


Etape 4:CrÃ©er des fichiers HTML

Headers HTTP = niveau transport/rÃ©seau ğŸ“¡
self.send_header("Content-type", "text/html") â†’ dit au navigateur "je vais tâ€™envoyer du HTML".

Head HTML = niveau contenu/affichage ğŸ¨
Le <head> du HTML â†’ dit "voici comment interprÃ©ter mon document HTML" (encodage, CSS, JS, titre, etc).

Etape 5 : ajout JS PR LE Formulaire
Verifier les erreurs de jS dans la console du navigateur

La meilleure pratique moderne d'appel d'evenementsâ†’ toujours utiliser addEventListener










RAPPELS PYTHON ------------------------------------------------------------

Les tuples ressemblent aux listes, mais on ne peut pas les modifier une fois quâ€™ils ont Ã©tÃ© crÃ©Ã©s.
Le f devant les triples guillemets lorsqu'on ecrit du HTML au sein du python permet lâ€™interpolation des variables.

"r" = lecture

"b" = mode binaire (renvoie des bytes, pas du texte)


RACCOURCIS-----------------------------------------------------------------------
! te fait le squelette d'une page HTML


NOTIONS A COMPRENDRE-------------------------------------------------------------

Fichier systÃ¨me : ce sont tes fichiers qui existent sur ton disque dur (par ex. templates/home.html, static/apricots.jpg).
â†’ Ce sont de simples fichiers sur ton ordinateur.

URL (Uniform Resource Locator) : câ€™est ce que ton navigateur connaÃ®t et demande, comme http://127.0.0.1:8000/home ou http://127.0.0.1:8000/static/apricots.jpg.
â†’ Ce nâ€™est pas le chemin du disque, mais une "adresse" qui dit au navigateur : Â« donne-moi cette ressource auprÃ¨s du serveur Â».

âš ï¸ Ton navigateur ne peut pas aller fouiller dans ton disque (heureusement, sinon ce serait une faille de sÃ©curitÃ© Ã©norme).
Il passe toujours par ton serveur qui est comme un "gardien" :

il reÃ§oit la requÃªte (par ex. /static/apricots.jpg),

il dÃ©cide quoi faire,

puis il rÃ©pond avec le bon contenu.

Pourquoi le navigateur ne peut pas "lire directement" lâ€™image ?

Parce que le navigateur nâ€™a pas accÃ¨s direct Ã  ton disque (C:\Users\... ou /home/...).

Il ne peut parler quâ€™en HTTP avec un serveur web.

Câ€™est le serveur qui fait le lien entre "URL demandÃ©e" et "fichier sur le disque".
Navigateur (Chrome/Firefox/etc.)
        |
        | 1. Envoie une requÃªte HTTP
        |    (GET /home  ou  GET /static/apricots.jpg)
        v
Serveur Python (ton script)
        |
        | 2. VÃ©rifie l'URL demandÃ©e :
        |    - /home   â†’ lire templates/home.html
        |    - /about  â†’ lire templates/about.html
        |    - /static/apricots.jpg â†’ lire static/apricots.jpg
        v
Disque dur (fichiers du projet)
        |
        | 3. RÃ©cupÃ¨re le fichier correspondant
        v
Serveur Python
        |
        | 4. Envoie une rÃ©ponse HTTP
        |    + les octets du fichier demandÃ©
        v
Navigateur
        |
        | 5. Affiche la page ou lâ€™image


Un fichier statique = un fichier qui ne change pas en fonction de lâ€™utilisateur ou dâ€™une logique cÃ´tÃ© serveur.

Mode binaire (rb) â†’ Python lit les octets bruts, sans transformation.
ğŸ‘‰ Câ€™est exactement ce quâ€™il faut pour envoyer des images, vidÃ©os, fichiers CSS, JS, etc. En gÃ©nÃ©ral il faut tjrs lire en mode rb et ensuite le navigateur grace aux infos de son header interprete comme il faut les octets envoyÃ©s dans le corps de la rÃ©ponse.

En gros, le serveur, lorsqu'il recoit un get du nav, envoit une rÃ©ponse. Cette rÃ©ponse se dÃ©coupe en header(metadonnÃ©es) et corps de rÃ©ponse. Dans le header sont les infos pour decrypter le corps de rÃ©ponse. Dnas le corps de rÃ©ponse se trouve la rÃ©ponse Ã  la demande en binaire. Un fois le nav qui recoit tout ca, il dÃ©crypte grace a son header le corps de la rÃ©ponse et transforme le binaire en html, image, css...

Bonnes pratiques :

âœ… SÃ©paration des templates dans un dossier templates/ â†’ clair et maintenable.

âœ… Gestion des fichiers statiques avec mimetypes â†’ nickel pour servir CSS, JS, imagesâ€¦

âœ… SÃ©curisation XSS avec html.escape() â†’ câ€™est exactement ce quâ€™il faut pour afficher du texte saisi par lâ€™utilisateur.

âœ… Routing simple (/home, /about, /contact) â†’ Ã§a marche bien pour un projet dâ€™initiation.

âœ… Retour dâ€™erreur 404 si la page nâ€™existe pas â†’ bonne pratique pour informer lâ€™utilisateur.